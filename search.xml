<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git项目创建]]></title>
    <url>%2F2017%2F08%2F29%2Fgit-base-1%2F</url>
    <content type="text"><![CDATA[git start git repository config 1234git initgit remote add origin https://xxx.xxx.xxx || git@git.xx.xxxgit config user.name xxxgit config user.email xxx start description git config 说明 remote add origin xxx 给本地仓库添加远程仓库 别名 origin git 添加远程仓库https ssh 方式是不同的 ssh 需要通用 ssh key 的方式本地生成ssh key的公钥和私钥将公钥配置到gitserver。ex: github-setting-ssh key https 每次push pull 都需要用户密码 用credential.helper 方式保存1234#windowgit config credential.helper=wincred#osxgit config redential.helper=osxkeychain — git 不同的登录方式ssh https 配置区别还是需要注意]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js对象概念]]></title>
    <url>%2F2017%2F08%2F28%2Fjs-base%2F</url>
    <content type="text"><![CDATA[js对象this 对象 this 指向和调用方式有关 函数调用 对象方法 new表达式 ==普通函数调用==，this为==全局对象或是undefined== ==作为对象的方法==，this为==那个对象== new 表达式，this为以该函数为原型的新创建的对象 使用 apply/call指定 this 这里this的指向根据函数的上下文 用bind绑定固定的this 事件处理函数中的this是当前的触发事件的DOM元素(event.currentTarget) IE attachEvent添加的事件处理函数中this为window 函数1.函数声明和 函数表达式 区别 在解释器 加载数据时候 有一个函数声明提升 function declaration hoisting 函数声明在任何代码之前可用 函数表达式必须等到解析器执行到它所在的代码行 2.函数调用的三种方式: obj.myFunc(); myFunc.call(obj,arg); myFunc.apply(obj,[arg1,arg2..]); call 连续参数 apply 接受 array arguments fun.call(thisArg[, arg1[, arg2[, …]]]) fun.apply(thisArg, [argsArray]) 参考文档 3.构造函数： 这个新创建的对象的 prototype 被指向到构造函数的 prototype。 通过 new 关键字方式调用的函数都被认为是构造函数。 在构造函数内部 也就是被调用的函数内 this 指向新创建的对象 Object。 4.原型对象 原型对象：有 constructor 指针指向构造函数. 是不安全属性容易被重写！ 实例：指向原型对象的内部指针 [proto ]. constructor 属性默认调用prototype对象的constructor. All objects inherit a constructor property from their prototype: arguments对象 转换成数组 var args = Array.prototype.silce.call(arguments); callee 属性 指向拥有arguments对象的函数 object 对象1.Object.defineProperty() 参数 对象，属性，描述符（descriptor）descriptor: configurable emumerable writable value 中一个或多个。 configurable true 可以从对象属性删除 false 不能从对象属性删除 delete会报错 emumerable writable true 可读写， flase 只读 value 属性的值]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2017%2F08%2F28%2Fgit-base%2F</url>
    <content type="text"><![CDATA[Git实践 Git 有三种状态 已提交（committed） 已修改（modified） 已暂存（staged） Git global setup: 12git config --global user.name "username"git config --global user.email "username@baidu.cn" Create Repository 1234git initgit config user.name "username"git config credential.helper wincred //Caching password in git git remote add origin https://git.corp.qihoo.net/kidsguard-web/elder.git delete remote branch 1git push origin --delete branchName GIT关键字 pull 拉取远程的repo 仓库内容 fetch push 将修改推送到远程的仓库 checkout 切换分支 branch test 创建test 分支 rebase 修改master指针的位置，使得本branch上面的提交都在最新master之后保持提交树的线性关系。 add 这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 reset SHA 会保留工作目录（working directory）。这些提交虽然消失了，但是内容还在磁盘上 reset –hard SHA “撤销”所有提交和本地修改 (-hard不保留本地磁盘数据) pull &amp; push (push 类似)123git pull &lt;远程主机名&gt;&lt;远程分支名&gt;:&lt;本地分支名&gt;git pull origin next:master //origin主机的next分支，与本地的master分支合并。git pull origin next //远程分支是与当前分支合并 reset1234git reset -soft head~ 回滚到前一次提交之前git reset --hard HEAD~~ 回滚到前一次提交git reset --hard &lt;commit ID号&gt;git push -f 回滚远程提交的 checkout123git checkout -b newtest 本地新建一个名为newtest的分支git checkout -b localtest origin/test 创建branch为localtest,repo为origin/test.git branch -u origin/my_branch change upstream 的分支 参数文档 Git猴子入门参考文档 GIT 特性和基本命令 基于快照]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[柯里化]]></title>
    <url>%2F2017%2F08%2F28%2Fjs-curry%2F</url>
    <content type="text"><![CDATA[柯里化 延时计算 通用写法1234567891011121314151617181920var currying = function (fn) &#123; var _args = []; function base() &#123; if (arguments.length === 0) &#123; return fn.apply(this, _args); &#125; else &#123; Array.prototype.push.apply(_args, [].slice.call(arguments)); return logic; &#125; &#125; return base;&#125;;var add = currying(function()&#123; return [].slice.call(arguments).reduce(function(a,b)&#123; return a + b; &#125;);&#125;)add(1,2,3)(4)(5)();]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp常用插件]]></title>
    <url>%2F2017%2F08%2F28%2Fgulp-plugins%2F</url>
    <content type="text"><![CDATA[gulp-load-plugins 将所有gulp开头的文件load， $=require(“gulp-load-plugins”), 通过$访问gulp相关的插件。 gulp-load-plugins 这个插件能自动帮你加载package.json文件里的gulp插件。例如假设你的package.json文件里的依赖是这样的:也就是原始插件名去掉gulp-前缀，之后再转换为驼峰命名。 gulp-jade 编辑jade gulp-less 编辑less 文件 gulp-flatten 平面任意嵌套的数组，化成非数组项的非嵌套列表 gulp-plumber Prevent pipe breaking caused by errors from gulp plugins gulp-uglify 插件用来压缩js文件。 gulp-minify-css 插件用来压缩css文件。]]></content>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端设计知识库]]></title>
    <url>%2F2017%2F08%2F28%2Fdesign%2F</url>
    <content type="text"><![CDATA[移动端设计知识库关键词 px：physical pixel 设备能控制显示的最小单位，我们可以把这些像素看作成显示器上一个个的点。 css pxCSS像素是Web编程的概念，独立于设备的用于逻辑上衡量像素的单位，也就是说我在做网页时用到的CSS像素单位，是抽象的，而不是实际存在的。 pt: point，点，印刷行业常用单位，等于1/72英寸 dip 设备独立像素 (DIP，device-independent pixel，density-independent pixel)(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用并控制的虚拟像素(比如：CSS 像素,只是在android机中CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”)， 然后由相关系统转换为物理像素。 dip或dp，是安卓开发用的单位 比较单位DPI 点每英寸 dpi (dots per inch)： 打印分辨率 （每英寸所能打印的点数，即打印精度） PPI 像素每英寸ppi (pixels per inch)：图像分辨率 （在图像中，每英寸所包含的像素数目） 计算方法是通过勾股定理算出来对角线包含的像素点然后除以对角线的长度(英寸)得来的 ppi和dpi经常都会出现混用现象。但是他们所用的领域也存在区别。从技术角度说，“像素”只存在于电脑显示领域，而“点”只出现于打印或印刷领域。 PPI 参数数据安卓端 PPI 参数 苹果设备 PPI 参数 思考 PS中的分辨率/寸指的是什么？ 做web设计的时候通常设置为72 ？ 做图片输出的时候通常设置为300 ？ 苹果鼓吹的retina又是什么呢？1080p 4k 等概念？ 分辨率 分为显示分辨率 和 图片分辨率 分别指什么？独立完成思考题，恭喜你 完成本课程学习！]]></content>
      <tags>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[viewport适口]]></title>
    <url>%2F2017%2F04%2F28%2Fhtml-view%2F</url>
    <content type="text"><![CDATA[手机屏幕相对着桌面浏览器小，传统网页的设计在手机上体验糟糕Apple 在移动版 Safari 中定义了 viewport meta 标签(如果没记错最早提出的话)，用于创建一个虚拟窗口（layout viewport），这个虚拟窗口的分辨率接近于桌面显示器，Apple 将其定义为980px。然后将虚拟窗口映射到移动设备的屏幕上，按比例缩放并重新渲染网页。 虚拟窗口（layout viewport） 把 viewport 设置为一个比较宽的值（防止太窄而在可视区域中显示错乱）。该默认的 viewport 称为 layout viewport。宽度可通过 Js 获取(基本所有设备都支持) 视觉窗口（visual viewport） 浏览器可视区域大小。可理解为手机物理屏幕。宽度可通过 Js 获取(不支持Android2, Opera Mini, UC8) window.innerWidth window.innerHeight ideal viewport 由Peter-Paul Koch提出的一种概念，一个完美适配移动设备的 viewport。理想状态是不需要用户缩放和横向滚动条就能正常查看，显示的文字大小合适，不区分分辨率，屏幕密度等。 &lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=0&quot;&gt; meta viewport 移动端默认使用的是 layout viewport ，而我们想要达到类似 ideal viewport 的效果的话，可以通过 meta 标签来对 viewport 进行控制。 width=device-width 因为meta viewport中的width能控制layout viewport的宽度，所以我们只需要把width设为width-device这个特殊的值就行了。 设备像素比 = 设备像素/设备独立像素 设备独立像素 = 设备像素/设备像素比 独立设备像素 就是 css 中的px 独立于设备的用于逻辑上衡量像素的单位。]]></content>
      <tags>
        <tag>viewport</tag>
      </tags>
  </entry>
</search>
